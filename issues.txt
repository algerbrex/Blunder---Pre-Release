package main

import (
	"blunder/core"
	inter "blunder/interface"
	"flag"
	"fmt"
	"log"
	"os"
	"runtime/pprof"
)

var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")

func main() {
	flag.Parse()
	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal(err)
		}
		pprof.StartCPUProfile(f)
		defer pprof.StopCPUProfile()
	}

	var searcher core.Searcher
	searcher.Init()
	searcher.LoadFEN("rn2k2r/p1ppqpb1/b3pnp1/3PN3/1p2P3/R1N2Q1p/PPPBBPPP/R3K3 w Qkq - 0 1")
	bestMove := searcher.Search()
	fmt.Println("Best move:", core.MoveToStr(bestMove))
	fmt.Println("Nodes explored:", searcher.NodesExplored)
	fmt.Println("Transposition table hits:", searcher.TTHits)
	//var board core.Board
	//board.LoadFEN(core.FENStartPosition)
	//tests.RunAllZobristHashingTests(&board, false)
	inter.RunUCIProtocol()
}












// Perform a static exchange evaluation (see) of the position. Basically, for each capture we
// have, get all of our pieces that are attacking the piece, and all of the opponets peices
// that are defending the piece. And if, starting with our least valuable attackers we emerge
// from the exchange up material, then that capture needs to be ranked higher.
func StaticExchangeEvaluation(searcher *Searcher, square int) (score int) {
	timeit(time.Now())
	enemyColor, usColor := WhiteBB, BlackBB
	if searcher.Board.WhiteToMove {
		enemyColor = BlackBB
		usColor = WhiteBB
	}

	attackers := attackersOfSquare(&searcher.Board, usColor, setSingleBit(square), searcher.Board.PieceBB[enemyColor])
	protectors := attackersOfSquare(&searcher.Board, enemyColor, setSingleBit(square), searcher.Board.PieceBB[usColor])

	attackerValues := [15]int{}
	protectorValues := [15]int{}

	for index := 0; attackers != 0; index++ {
		pos, _ := popLSB(&attackers)
		attackerValues[index] = getPieceValue(GetPieceType(searcher.Board.Pieces[pos]))
	}

	for index := 0; protectors != 0; index++ {
		pos, _ := popLSB(&protectors)
		protectorValues[index] = getPieceValue(GetPieceType(searcher.Board.Pieces[pos]))
	}

	sortPieceValues(&attackerValues)
	sortPieceValues(&protectorValues)

	fmt.Println(attackerValues)
	fmt.Println(protectorValues)
	panic("")

	score += getPieceValue(GetPieceType(searcher.Board.Pieces[square]))
	for valOnSq, index := 0, 0; index < 15; index++ {
		if protectorValues[index] != 0 && attackerValues[index] != 0 {
			score -= valOnSq
		} else if protectorValues[index] != 0 {
			valOnSq = protectorValues[index]
		} else if attackerValues[index] != 0 {
			valOnSq = attackerValues[index]
		}
	}
	return score
}




















package core

const (
	// Max search depth of the engine
	SearchDepth = 6
	// Max quiesence search depth of engine
	QuiesenceSearchDepth = 3
	// Represents a null best move, which should
	// never actually be returned from the search
	NullMove uint16 = 0
)

// This object provides a conveient container for
// holding the state needed during a search, mainly
// the board, and transposition table.
type Searcher struct {
	Board       Board
	GameHistory map[uint64]int
	ttable      TranspositionTable

	// Variables to store information useful for debugging the engine
	NodesExplored uint64
}

// Initalize the searcher
func (seacher *Searcher) Init() {
	seacher.ttable.InitTable()
	seacher.GameHistory = make(map[uint64]int)
}

// Load a fen string into the searcher
func (seacher *Searcher) LoadFEN(fen string) {
	seacher.Board.LoadFEN(fen)
}

// Get the best move to play via iterative deepening
func (searcher *Searcher) Search() uint16 {
	bestMove := NullMove
	for depth := 1; depth <= SearchDepth; depth++ {
		bestMove = searcher.rootNegamax(depth)
	}
	return bestMove
}

// Get the best move for the side to move in the current board
func (searcher *Searcher) rootNegamax(depth int) uint16 {
	var moves []uint16
	genLegalMoves(&searcher.Board, &moves)
	orderMoves(&searcher.Board, &moves)

	alpha, beta := NegInf, PosInf-1
	bestMove := NullMove
	pvFound := false
	var score int

	for _, move := range moves {
		searcher.Board.DoMove(&move, true)
		if pvFound {
			score = -searcher.negamax(depth-1, -alpha-1, -alpha)
			if score > alpha && score < beta {
				score = -searcher.negamax(depth-1, -beta, -alpha)
			}
		} else {
			score = -searcher.negamax(depth-1, -beta, -alpha)
		}
		searcher.Board.UndoMove(&move)

		if score > alpha {
			alpha = score
			bestMove = move
			pvFound = true
		}
		if score >= beta {
			break
		}
	}
	return bestMove
}

// The root negamax function in the searcher calls this main
// negamax function, which only returns an integer value representing
// the score of the best move found, which is all that's needed for
// the top-level call to get a best move.
func (searcher *Searcher) negamax(depth, alpha, beta int) int {
	if depth == 0 {
		searcher.NodesExplored++
		return searcher.quiescence(QuiesenceSearchDepth, alpha, beta)
	}

	var moves []uint16
	genLegalMoves(&searcher.Board, &moves)

	if len(moves) == 0 {
		if searcher.Board.InCheck() {
			return NegInf + (SearchDepth - depth)
		}
		return 0
	}

	orderMoves(&searcher.Board, &moves)
	pvFound := false
	var score int

	for _, move := range moves {
		searcher.Board.DoMove(&move, true)
		if pvFound {
			score = -searcher.negamax(depth-1, -alpha-1, -alpha)
			if score > alpha && score < beta {
				score = -searcher.negamax(depth-1, -beta, -alpha)
			}
		} else {
			score = -searcher.negamax(depth-1, -beta, -alpha)
		}
		searcher.Board.UndoMove(&move)
		if score >= beta {
			return beta
		}
		if score > alpha {
			alpha = score
			pvFound = true
		}
	}
	return alpha
}

func (searcher *Searcher) quiescence(depth, alpha, beta int) int {
	stand_pat := evaluateBoard(searcher)
	if depth == 0 {
		return stand_pat
	}
	if stand_pat >= beta {
		return beta
	}
	if alpha < stand_pat {
		alpha = stand_pat
	}

	var moves []uint16
	genLegalMoves(&searcher.Board, &moves)
	orderMoves(&searcher.Board, &moves)

	for _, move := range moves {
		_, _, moveType := GetMoveInfo(move)
		if moveType == Attack || move == AttackEP {
			searcher.Board.DoMove(&move, true)
			score := -searcher.quiescence(depth-1, -beta, -alpha)
			searcher.Board.UndoMove(&move)

			if score >= beta {
				return beta
			}
			if score > alpha {
				alpha = score
			}
		}
	}
	return alpha
}

// Order the moves with those that are most likley to be best (e.g.
// capturing a piece with a pawn), to optimize alpha-beta pruning.
func orderMoves(board *Board, moves *[]uint16) {
	moveScores := make([]int, len(*moves))
	for moveIndex, move := range *moves {
		from, to, moveType := GetMoveInfo(move)
		movePieceType := GetPieceType(board.Pieces[from])
		capturePieceType := GetPieceType(board.Pieces[to])

		if moveType == Attack || moveType == AttackEP {
			moveScores[moveIndex] = getPieceValue(capturePieceType) - getPieceValue(movePieceType)
		} else if moveType == KnightPromotion {
			moveScores[moveIndex] = KnightValue + getPieceValue(capturePieceType)
		} else if moveType == BishopPromotion {
			moveScores[moveIndex] = BishopValue + getPieceValue(capturePieceType)
		} else if moveType == RookPromotion {
			moveScores[moveIndex] = RookValue + getPieceValue(capturePieceType)
		} else if moveType == QueenPromotion {
			moveScores[moveIndex] = QueenValue + getPieceValue(capturePieceType)
		} else if moveType == Quiet {
			// Make sure quiet moves are behind attacking moves which seem to "trade"
			// pieces (i.e. the piece capturing the captured piece are of equal value)
			// but might actually win material. But make sure they're still ahead of dumb
			// blundering captures. This is done by setting the value of a purely quite move
			// to negatve one.
			moveScores[moveIndex] = -1
		}
	}
	sortMoves(moves, &moveScores)
}

// A helper function to sort the moves given an array with a moves
// score corresponding to it's index.
func sortMoves(moves *[]uint16, moveScores *[]int) {
	for i := 0; i < len(*moves)-1; i++ {
		for j := i + 1; j > 0; j-- {
			swapIndex := j - 1
			if (*moveScores)[swapIndex] < (*moveScores)[j] {
				(*moves)[j], (*moves)[swapIndex] = (*moves)[swapIndex], (*moves)[j]
				(*moveScores)[j], (*moveScores)[swapIndex] = (*moveScores)[swapIndex], (*moveScores)[j]
			}
		}
	}
}

































package core

import (
	"math/bits"
)

const (
	PawnValue   = 100
	KnightValue = 320
	BishopValue = 330
	RookValue   = 500
	QueenValue  = 975

	// These values are not actually infinity of course, or verfy large,
	// but functional for negascout they will be.
	PosInf = 2000000
	NegInf = -PosInf

	// Value of a draw
	DrawValue = 0
)

// Piece-square table for pawns
var PawnPST [64]int = [64]int{
	25, 25, 25, 25, 25, 25, 25, 25,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	-5, -5, -5, -5, -5, -5, -5, -5,
	-15, -2, 3, 15, 15, 3, -2, -15,
	-15, 2, 5, 5, 5, 5, 2, -15,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
}

// Piece-square table for knights
var KnightPST [64]int = [64]int{
	-15, -15, -15, -15, -15, -15, -15, -15,
	-2, -2, -2, -2, -2, -2, -2, -2,
	-5, 0, 2, 2, 2, 2, 0, -5,
	-5, 0, 15, 25, 25, 15, 0, -5,
	-5, 0, 15, 25, 25, 15, 0, -5,
	-5, 0, 25, 25, 25, 25, 0, -5,
	-2, -2, -2, -2, -2, -2, -2, -2,
	-15, -15, -15, -15, -15, -15, -15, -15,
}

// Piece-square table for bishops
var BishopPST [64]int = [64]int{
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	2, 5, 5, 0, 0, 5, 5, 2,
	2, 15, 5, 0, 0, 5, 15, 2,
	2, -5, -25, 0, 0, -25, -5, 2,
}

// Piece-square table for rooks
var RookPST [64]int = [64]int{
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 25, 25, 25, 25, 0, 0,
	0, 0, 25, 25, 25, 25, 0, 0,
	-15, 0, 25, 35, 35, 25, 0, -15,
}

var QueenMiddleGamePST [64]int = [64]int{
	-25, -25, -25, -25, -25, -25, -25, -25,
	-10, -10, -10, -10, -10, -10, -10, -10,
	-5, -5, -5, -5, -5, -5, -5, -5,
	-2, -2, -5, -5, -5, -5, -2, -2,
	-2, -2, 2, 2, 2, 2, -2, -2,
	-2, -2, 5, 5, 5, 5, 0, -2,
	0, 0, 2, 2, 2, 2, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
}

var QueenEndGamePST [64]int = [64]int{
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 15, 15, 15, 15, 0, 0,
	0, 0, 15, 35, 35, 15, 0, 0,
	0, 0, 15, 15, 15, 15, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,
}

var KingMiddleGamePST [64]int = [64]int{
	-10, -10, -10, -25, -25, -10, -10, -10,
	-10, -10, -10, -25, -25, -10, -10, -10,
	-10, -10, -10, -25, -25, -10, -10, -10,
	-10, -10, -10, -25, -25, -10, -10, -10,
	-10, -10, -10, -25, -25, -10, -10, -10,
	-10, -10, -10, -10, -10, -10, -10, -10,
	25, 25, -10, -10, -10, -10, 25, 25,
	50, 50, 0, 0, 0, 0, 50, 50,
}

var KingEndGamePST [64]int = [64]int{
	-10, -10, -10, -10, -10, -10, -10, -10,
	-10, -5, -5, -5, -5, -5, -5, -10,
	-10, 2, 5, 5, 5, 5, 2, -10,
	-10, 2, 5, 25, 25, 5, 2, -10,
	-10, 2, 5, 25, 25, 5, 2, -10,
	-10, 2, 5, 5, 5, 5, 2, -10,
	-10, -5, -5, -5, -5, -5, -5, -10,
	-10, -10, -10, -10, -10, -10, -10, -10,
}

// Evaluate a board state.
func evaluateBoard(searcher *Searcher) (score int) {
	/*if searcher.GameHistory[searcher.Board.Hash] == 1 {
		// Detect if a 3-fold repition is about to occur
		// score the position as a draw. Be premptive and
		// don't let the computer pointlessly repeat moves
		// in the first place.
		//fmt.Println("REACHED")
		return 0
	}*/
	whiteScore := evaluateSide(&searcher.Board, WhiteBB)
	blackScore := evaluateSide(&searcher.Board, BlackBB)

	if searcher.Board.WhiteToMove {
		return whiteScore - blackScore
	}
	return blackScore - whiteScore
}

// Evaluate a board state for a side.
func evaluateSide(board *Board, usColor int) (score int) {
	score += evaluateMaterial(board, usColor)
	score += evaluatePosition(board, usColor)
	return score
}

// Evalute the material for a side.
func evaluateMaterial(board *Board, usColor int) (score int) {
	score += bits.OnesCount64(board.PieceBB[PawnBB]&board.PieceBB[usColor]) * PawnValue
	score += bits.OnesCount64(board.PieceBB[KnightBB]&board.PieceBB[usColor]) * KnightValue
	score += bits.OnesCount64(board.PieceBB[BishopBB]&board.PieceBB[usColor]) * BishopValue
	score += bits.OnesCount64(board.PieceBB[RookBB]&board.PieceBB[usColor]) * RookValue
	score += bits.OnesCount64(board.PieceBB[QueenBB]&board.PieceBB[usColor]) * QueenValue
	return score
}

// Evaluate the position of a side using piece square tables
func evaluatePosition(board *Board, usColor int) (score int) {
	for index := 0; index < 64; index++ {
		piece := board.Pieces[index]
		pieceType, pieceColor := GetPieceType(piece), getPieceColor(piece)
		if pieceColor == usColor {
			// The piece-square tables are from blacks perspective,
			// so when white is the color to move, flip the index
			// and perspective
			perspective := index
			if usColor == WhiteBB {
				perspective = 63 - index
			}

			switch pieceType {
			case PawnBB:
				score += PawnPST[perspective]
			case KnightBB:
				score += PawnPST[perspective]
			case BishopBB:
				score += PawnPST[perspective]
			case RookBB:
				score += PawnPST[perspective]
			case QueenBB:
				if board.IsEndgame() {
					score += QueenEndGamePST[perspective]
				} else {
					score += QueenMiddleGamePST[perspective]
				}
			case KingBB:
				if board.IsEndgame() {
					score += KingEndGamePST[perspective]
				} else {
					score += KingMiddleGamePST[perspective]
				}

			}
		}
	}
	return score
}

// A convinece function to get a pieces value given
// its bitboard index.
func getPieceValue(pieceType int) int {
	switch pieceType {
	case QueenBB:
		return QueenValue
	case RookBB:
		return RookValue
	case BishopBB:
		return BishopValue
	case KnightBB:
		return KnightValue
	case PawnBB:
		return PawnValue
	default:
		return 0
	}
}
























// Score the king saftey of the engine
func evaluateKingSaftey(board *Board, usColor int) (score int) {
	usBB := board.PieceBB[usColor]
	kingMoves := KingMoves[getLSBPos(board.PieceBB[KingBB]&usBB)]
	piecesAroundKing := kingMoves & usBB
	for piecesAroundKing != 0 {
		piecePos, _ := popLSB(&piecesAroundKing)
		pieceType := GetPieceType(board.Pieces[piecePos])
		score += (getPieceValue(pieceType) / 15)
	}

	enemyColor := WhiteBB
	if usColor == WhiteBB {
		enemyColor = BlackBB
	}
	for kingMoves != 0 {
		_, kingMove := popLSB(&kingMoves)
		attackers := attackersOfSquare(board, enemyColor, kingMove, usBB)
		for attackers != 0 {
			attackerPos, _ := popLSB(&attackers)
			attackerType := GetPieceType(board.Pieces[attackerPos])
			score -= (getPieceValue(attackerType) / 15)
		}
	}
	return score
}

// Get the distance between any two squares on a chess-board. Since two squares
// might not always be on the same rank, file, diagonal, or anti-diagonal, the
// Pythagorean theorem distance formula is used as an estimate for the distance
// between ANY two squares.
func distBetweenSquares(s1, s2 int) int {
	x1, y1 := s1%8, s1/8
	x2, y2 := s2%8, s2/8
	xDist := math.Pow(float64(x2-x1), 2)
	yDist := math.Pow(float64(y2-y1), 2)
	return min(int(math.Sqrt(xDist+yDist)), 8)
}











[Event "?"]
[Site "?"]
[Date "2021.06.29"]
[Round "?"]
[White "Blunder 0.2"]
[Black "Blunder 0.3"]
[Result "0-1"]
[FEN "r1bqkbnr/pp1npppp/2p5/8/3PN3/8/PPP2PPP/R1BQKBNR w KQkq - 1 5"]
[GameDuration "00:06:35"]
[GameEndTime "2021-06-29T12:18:57.569 CDT"]
[GameStartTime "2021-06-29T12:12:22.227 CDT"]
[PlyCount "48"]
[SetUp "1"]
[TimeControl "inf"]

1. Qf3 {12s} e5 {4.7s} 2. dxe5 {20s} Nxe5 {10s} 3. Qh5 {15s} Qa5+ {9.8s}
4. Nd2 {5.5s} Nd3+ {9.1s} 5. Bxd3 {0.73s} Qxh5 {3.4s} 6. Ne2 {12s} Bd6 {6.8s}
7. Nc4 {27s} Bb8 {3.5s} 8. Be3 {14s} Be6 {17s} 9. Kf1 {20s} Nf6 {17s}
10. Nd4 {26s} Ng4 {7.1s} 11. Nxe6 {3.4s} fxe6 {3.7s} 12. Bd4 {5.8s} e5 {8.7s}
13. Re1 {3.6s} O-O {7.5s} 14. Bc5 {3.0s} Rd8 {6.3s} 15. Kg1 {7.4s} e4 {6.7s}
16. Be7 {7.3s} Bxh2+ {3.7s} 17. Kf1 {1.2s} Qf7 {3.5s} 18. f3 {6.7s} Rd4 {4.0s}
19. Ne3 {7.6s} exd3 {3.4s} 20. Nxg4 {5.3s} Bg3 {2.8s} 21. Nf2 {12s} d2 {10s}
22. Re2 {8.0s} d1=Q+ {5.4s} 23. Nxd1 {1.1s} Rxd1+ {14s} 24. Re1
Rxe1# {0.68s, Black mates} 0-1













Enter a fen string for the starting position (or startpos for the start position): 
3Nb2r/1RP4p/5k1n/1P6/2r5/p5K1/8/8 b - - 0 55
Are you white or black? 
black
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . r . . . . . 
3 | p . . . . . K . 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: Black
Castling rights: 
En passant square: None
Half-move clock: 0
Full-move counter: 5
Zobrist hash: 0x5703e74355c810f4

Enter your move (in uci protocol formation): 
c4c3

HERE:
 map[16582254672763348706:1]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . . . . . . . 
3 | p . r . . . K . 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: White
Castling rights: 
En passant square: None
Half-move clock: 1
Full-move counter: 5
Zobrist hash: 0xe62000c4b11ee6e2

Thinking...
Computer plays the move: g3-h4

HERE:
 map[16582254672763348706:1 16815074048194716187:1]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . . . . . . K 
3 | p . r . . . . . 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: Black
Castling rights: 
En passant square: None
Half-move clock: 2
Full-move counter: 6
Zobrist hash: 0xe95b24c1ba89221b

Enter your move (in uci protocol formation): 
c3c4

HERE:
 map[6375059979541402637:1 16582254672763348706:1 16815074048194716187:1]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . r . . . . K 
3 | p . . . . . . . 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: White
Castling rights: 
En passant square: None
Half-move clock: 3
Full-move counter: 6
Zobrist hash: 0x5878c3465e5fd40d

Thinking...
Computer plays the move: h4-h3

HERE:
 map[4416572392848433522:1 6375059979541402637:1 16582254672763348706:1 16815074048194716187:1]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . r . . . . . 
3 | p . . . . . . K 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: Black
Castling rights: 
En passant square: None
Half-move clock: 4
Full-move counter: 7
Zobrist hash: 0x3d4ad130f8872172

Enter your move (in uci protocol formation): 
c4c3

HERE:
 map[4416572392848433522:1 6375059979541402637:1 10117678197946570596:1 16582254672763348706:1 16815074048194716187:1]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . . . . . . . 
3 | p . r . . . . K 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: White
Castling rights: 
En passant square: None
Half-move clock: 5
Full-move counter: 7
Zobrist hash: 0x8c6936b71c51d764

Thinking...
Computer plays the move: h3-h4

HERE:
 map[4416572392848433522:1 6375059979541402637:1 10117678197946570596:1 16582254672763348706:1 16815074048194716187:2]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . . . . . . K 
3 | p . r . . . . . 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: Black
Castling rights: 
En passant square: None
Half-move clock: 6
Full-move counter: 8
Zobrist hash: 0xe95b24c1ba89221b

Enter your move (in uci protocol formation): 
c3c4

HERE:
 map[4416572392848433522:1 6375059979541402637:2 10117678197946570596:1 16582254672763348706:1 16815074048194716187:2]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . r . . . . K 
3 | p . . . . . . . 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: White
Castling rights: 
En passant square: None
Half-move clock: 7
Full-move counter: 8
Zobrist hash: 0x5878c3465e5fd40d

Thinking...
Computer plays the move: h4-h3

HERE:
 map[4416572392848433522:2 6375059979541402637:2 10117678197946570596:1 16582254672763348706:1 16815074048194716187:2]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . r . . . . . 
3 | p . . . . . . K 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: Black
Castling rights: 
En passant square: None
Half-move clock: 8
Full-move counter: 9
Zobrist hash: 0x3d4ad130f8872172

Enter your move (in uci protocol formation): 
c4c3

HERE:
 map[4416572392848433522:2 6375059979541402637:2 10117678197946570596:2 16582254672763348706:1 16815074048194716187:2]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . . . . . . . 
3 | p . r . . . . K 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: White
Castling rights: 
En passant square: None
Half-move clock: 9
Full-move counter: 9
Zobrist hash: 0x8c6936b71c51d764

REACHED
Thinking...
Computer plays the move: h3-h4

HERE:
 map[4416572392848433522:2 6375059979541402637:2 10117678197946570596:2 16582254672763348706:1 16815074048194716187:3]
CURRENT BOARD:

8 | . . . N b . . r 
7 | . R P . . . . p 
6 | . . . . . k . n 
5 | . P . . . . . . 
4 | . . . . . . . K 
3 | p . r . . . . . 
2 | . . . . . . . . 
1 | . . . . . . . . 
   ----------------
    a b c d e f g h 

Whose move: Black
Castling rights: 
En passant square: None
Half-move clock: 10
Full-move counter: 10
Zobrist hash: 0xe95b24c1ba89221b

Enter your move (in uci protocol formation):


// TODO (Bug!): king not included in square attackers! -> FIXED
// TODO (Potential Bug!): king can't capture checker if it's protected! -> FIXED
// TODO (Potential Bug!): Nasty castling bugs. Look back at Blunder 0.3
// for details!

	/*var moves []uint16 = []uint16{49792, 49664, 64320, 64240, 64208, 59184, 59040, 59008, 63328, 63296, 63216, 63152, 63008, 62864, 62720, 60208, 60176, 60096, 60032, 59984, 59872, 59761, 65392, 65264, 65136, 65008, 64881, 61248, 61216, 61136, 61072, 61024, 60928, 60912, 61232, 61104, 60976, 60848, 60720, 60593, 62288, 62272, 62256}
	for _, move := range moves {
		fmt.Println(backend.MoveToStr(move))
	}
	fmt.Println(len(moves))*/


var depth4 uint16
var depth3 uint16
var depth2 uint16

var b4 Board
var b3 Board
var b2 Board

if depth == 4 {
			depth4 = move
			b4 = *board
		} else if depth == 3 {
			depth3 = move
			b3 = *board
		} else if depth == 2 {
			depth2 = move
			b2 = *board
		}
		moveNodes := dividePerft(board, depth-1, divdeAt)
		if depth == divdeAt {
			fmt.Printf("%v: %v\n", MoveToStr(move), moveNodes)
		}
		nodes += moveNodes
		board.UndoMove(&move)
		if board.Pieces[48] == NoPiece && board.Pieces[49] == NoPiece {
			/*fmt.Println("depth 4:", MoveToStr(depth4))
			b4.PrintBoard()

			fmt.Println("depth 3:", MoveToStr(depth3))
			b3.PrintBoard()

			fmt.Println("depth 2:", MoveToStr(depth2))
			b2.PrintBoard()

			fmt.Println("depth 1:", MoveToStr(move))
			board.PrintBoard()*/
			panic("stop!")
		}








board.PrintBoard()
backend.Print2dBitboard(board.PieceBB[backend.WhiteBB] | board.PieceBB[backend.BlackBB])
move := backend.MakeMove(0, 6, backend.CastleWKS)
board.DoMove(&move)
board.PrintBoard()
backend.Print2dBitboard(board.PieceBB[backend.WhiteBB] | board.PieceBB[backend.BlackBB])
board.UndoMove(&move)
board.PrintBoard()
backend.Print2dBitboard(board.PieceBB[backend.WhiteBB] | board.PieceBB[backend.BlackBB])



var board backend.Board
	//8/8/4k3/8/7K/4Pp2/8/8 b - - 1 1
	board.LoadFEN("2qk4/8/8/3Pp3/6K1/8/8/8 w - e6 0 1")
	// TODO (Bug!): king not included in square attackers! -> FIXED
	// TODO (Potential Bug!): king can't capture checker if it's protected!
	// TODO (Potential Bug!): Nasty castling bugs. Look back at Blunder 0.3
	// for details!
	//board.PrintBoard()
	moves := []uint16{}
	m := []uint16{}
	pinned := backend.GenPinnedPiecesMoves(
		&board, backend.BlackBB, backend.WhiteBB,
		board.PieceBB[backend.KingBB]&board.PieceBB[backend.WhiteBB],
		&m,
	)
	checkers := backend.AttackersOfSquare(
		&board,
		backend.BlackBB,
		board.PieceBB[backend.KingBB]&board.PieceBB[backend.WhiteBB],
		board.PieceBB[backend.WhiteBB],
	)
	//backend.Print2dBitboard(pinned)
	//backend.Print2dBitboard(checkers)
	backend.GenCheckMoves(
		&board,
		backend.BlackBB,
		backend.WhiteBB,
		board.PieceBB[backend.KingBB]&board.PieceBB[backend.WhiteBB],
		checkers,
		^pinned,
		&moves,
	)
	for _, move := range moves {
		backend.PrintMove(move)
	}




var Rays [8][64]uint64 = [8][64]uint64{
	{
		0x80808080808080, 0x40404040404040, 0x20202020202020, 0x10101010101010, 0x8080808080808, 0x4040404040404, 0x2020202020202, 0x1010101010101,
		0x808080808080, 0x404040404040, 0x202020202020, 0x101010101010, 0x80808080808, 0x40404040404, 0x20202020202, 0x10101010101,
		0x8080808080, 0x4040404040, 0x2020202020, 0x1010101010, 0x808080808, 0x404040404, 0x202020202, 0x101010101,
		0x80808080, 0x40404040, 0x20202020, 0x10101010, 0x8080808, 0x4040404, 0x2020202, 0x1010101,
		0x808080, 0x404040, 0x202020, 0x101010, 0x80808, 0x40404, 0x20202, 0x10101,
		0x8080, 0x4040, 0x2020, 0x1010, 0x808, 0x404, 0x202, 0x101,
		0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	},
	{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x8000000000000000, 0x4000000000000000, 0x2000000000000000, 0x1000000000000000, 0x800000000000000, 0x400000000000000, 0x200000000000000, 0x100000000000000,
		0x8080000000000000, 0x4040000000000000, 0x2020000000000000, 0x1010000000000000, 0x808000000000000, 0x404000000000000, 0x202000000000000, 0x101000000000000,
		0x8080800000000000, 0x4040400000000000, 0x2020200000000000, 0x1010100000000000, 0x808080000000000, 0x404040000000000, 0x202020000000000, 0x101010000000000,
		0x8080808000000000, 0x4040404000000000, 0x2020202000000000, 0x1010101000000000, 0x808080800000000, 0x404040400000000, 0x202020200000000, 0x101010100000000,
		0x8080808080000000, 0x4040404040000000, 0x2020202020000000, 0x1010101010000000, 0x808080808000000, 0x404040404000000, 0x202020202000000, 0x101010101000000,
		0x8080808080800000, 0x4040404040400000, 0x2020202020200000, 0x1010101010100000, 0x808080808080000, 0x404040404040000, 0x202020202020000, 0x101010101010000,
		0x8080808080808000, 0x4040404040404000, 0x2020202020202000, 0x1010101010101000, 0x808080808080800, 0x404040404040400, 0x202020202020200, 0x101010101010100,
	},
	{
		0x7f00000000000000, 0x3f00000000000000, 0x1f00000000000000, 0xf00000000000000, 0x700000000000000, 0x300000000000000, 0x100000000000000, 0x0,
		0x7f000000000000, 0x3f000000000000, 0x1f000000000000, 0xf000000000000, 0x7000000000000, 0x3000000000000, 0x1000000000000, 0x0,
		0x7f0000000000, 0x3f0000000000, 0x1f0000000000, 0xf0000000000, 0x70000000000, 0x30000000000, 0x10000000000, 0x0,
		0x7f00000000, 0x3f00000000, 0x1f00000000, 0xf00000000, 0x700000000, 0x300000000, 0x100000000, 0x0,
		0x7f000000, 0x3f000000, 0x1f000000, 0xf000000, 0x7000000, 0x3000000, 0x1000000, 0x0,
		0x7f0000, 0x3f0000, 0x1f0000, 0xf0000, 0x70000, 0x30000, 0x10000, 0x0,
		0x7f00, 0x3f00, 0x1f00, 0xf00, 0x700, 0x300, 0x100, 0x0,
		0x7f, 0x3f, 0x1f, 0xf, 0x7, 0x3, 0x1, 0x0,
	},
	{
		0x0, 0x8000000000000000, 0xc000000000000000, 0xe000000000000000, 0xf000000000000000, 0xf800000000000000, 0xfc00000000000000, 0xfe00000000000000,
		0x0, 0x80000000000000, 0xc0000000000000, 0xe0000000000000, 0xf0000000000000, 0xf8000000000000, 0xfc000000000000, 0xfe000000000000,
		0x0, 0x800000000000, 0xc00000000000, 0xe00000000000, 0xf00000000000, 0xf80000000000, 0xfc0000000000, 0xfe0000000000,
		0x0, 0x8000000000, 0xc000000000, 0xe000000000, 0xf000000000, 0xf800000000, 0xfc00000000, 0xfe00000000,
		0x0, 0x80000000, 0xc0000000, 0xe0000000, 0xf0000000, 0xf8000000, 0xfc000000, 0xfe000000,
		0x0, 0x800000, 0xc00000, 0xe00000, 0xf00000, 0xf80000, 0xfc0000, 0xfe0000,
		0x0, 0x8000, 0xc000, 0xe000, 0xf000, 0xf800, 0xfc00, 0xfe00,
		0x0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe,
	},
	{
		0x40201008040201, 0x20100804020100, 0x10080402010000, 0x8040201000000, 0x4020100000000, 0x2010000000000, 0x1000000000000, 0x0,
		0x402010080402, 0x201008040201, 0x100804020100, 0x80402010000, 0x40201000000, 0x20100000000, 0x10000000000, 0x0,
		0x4020100804, 0x2010080402, 0x1008040201, 0x804020100, 0x402010000, 0x201000000, 0x100000000, 0x0,
		0x40201008, 0x20100804, 0x10080402, 0x8040201, 0x4020100, 0x2010000, 0x1000000, 0x0,
		0x402010, 0x201008, 0x100804, 0x80402, 0x40201, 0x20100, 0x10000, 0x0,
		0x4020, 0x2010, 0x1008, 0x804, 0x402, 0x201, 0x100, 0x0,
		0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1, 0x0,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	},
	{
		0x0, 0x80000000000000, 0x40800000000000, 0x20408000000000, 0x10204080000000, 0x8102040800000, 0x4081020408000, 0x2040810204080,
		0x0, 0x800000000000, 0x408000000000, 0x204080000000, 0x102040800000, 0x81020408000, 0x40810204080, 0x20408102040,
		0x0, 0x8000000000, 0x4080000000, 0x2040800000, 0x1020408000, 0x810204080, 0x408102040, 0x204081020,
		0x0, 0x80000000, 0x40800000, 0x20408000, 0x10204080, 0x8102040, 0x4081020, 0x2040810,
		0x0, 0x800000, 0x408000, 0x204080, 0x102040, 0x81020, 0x40810, 0x20408,
		0x0, 0x8000, 0x4080, 0x2040, 0x1020, 0x810, 0x408, 0x204,
		0x0, 0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2,
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
	},
	{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x4000000000000000, 0x2000000000000000, 0x1000000000000000, 0x800000000000000, 0x400000000000000, 0x200000000000000, 0x100000000000000, 0x0,
		0x2040000000000000, 0x1020000000000000, 0x810000000000000, 0x408000000000000, 0x204000000000000, 0x102000000000000, 0x1000000000000, 0x0,
		0x1020400000000000, 0x810200000000000, 0x408100000000000, 0x204080000000000, 0x102040000000000, 0x1020000000000, 0x10000000000, 0x0,
		0x810204000000000, 0x408102000000000, 0x204081000000000, 0x102040800000000, 0x1020400000000, 0x10200000000, 0x100000000, 0x0,
		0x408102040000000, 0x204081020000000, 0x102040810000000, 0x1020408000000, 0x10204000000, 0x102000000, 0x1000000, 0x0,
		0x204081020400000, 0x102040810200000, 0x1020408100000, 0x10204080000, 0x102040000, 0x1020000, 0x10000, 0x0,
		0x102040810204000, 0x1020408102000, 0x10204081000, 0x102040800, 0x1020400, 0x10200, 0x100, 0x0,
	},
	{
		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
		0x0, 0x8000000000000000, 0x4000000000000000, 0x2000000000000000, 0x1000000000000000, 0x800000000000000, 0x400000000000000, 0x200000000000000,
		0x0, 0x80000000000000, 0x8040000000000000, 0x4020000000000000, 0x2010000000000000, 0x1008000000000000, 0x804000000000000, 0x402000000000000,
		0x0, 0x800000000000, 0x80400000000000, 0x8040200000000000, 0x4020100000000000, 0x2010080000000000, 0x1008040000000000, 0x804020000000000,
		0x0, 0x8000000000, 0x804000000000, 0x80402000000000, 0x8040201000000000, 0x4020100800000000, 0x2010080400000000, 0x1008040200000000,
		0x0, 0x80000000, 0x8040000000, 0x804020000000, 0x80402010000000, 0x8040201008000000, 0x4020100804000000, 0x2010080402000000,
		0x0, 0x800000, 0x80400000, 0x8040200000, 0x804020100000, 0x80402010080000, 0x8040201008040000, 0x4020100804020000,
		0x0, 0x8000, 0x804000, 0x80402000, 0x8040201000, 0x804020100800, 0x80402010080400, 0x8040201008040200,
	},
}










package backend

const (
	Rank1 = iota
	Rank2
	Rank3
	Rank4
	Rank5
	Rank6
	Rank7
	Rank8
)

const (
	FileA = iota
	FileB
	FileC
	FileD
	FileE
	FileF
	FileG
	FileH
)

var KnightMoves [64]uint64 = [64]uint64{
	// a1-h1
	0x20400000000000,
	0x10a00000000000,
	0x88500000000000,
	0x44280000000000,
	0x22140000000000,
	0x110a0000000000,
	0x8050000000000,
	0x4020000000000,

	// a2-h2
	0x2000204000000000,
	0x100010a000000000,
	0x8800885000000000,
	0x4400442800000000,
	0x2200221400000000,
	0x1100110a00000000,
	0x800080500000000,
	0x400040200000000,

	// a3-h3
	0x4020002040000000,
	0xa0100010a0000000,
	0x5088008850000000,
	0x2844004428000000,
	0x1422002214000000,
	0xa1100110a000000,
	0x508000805000000,
	0x204000402000000,

	// a4-h4
	0x40200020400000,
	0xa0100010a00000,
	0x50880088500000,
	0x28440044280000,
	0x14220022140000,
	0xa1100110a0000,
	0x5080008050000,
	0x2040004020000,

	// a5-h5
	0x402000204000,
	0xa0100010a000,
	0x508800885000,
	0x284400442800,
	0x142200221400,
	0xa1100110a00,
	0x50800080500,
	0x20400040200,

	// a6-h6
	0x4020002040,
	0xa0100010a0,
	0x5088008850,
	0x2844004428,
	0x1422002214,
	0xa1100110a,
	0x508000805,
	0x204000402,

	// a7-h7
	0x40200020,
	0xa0100010,
	0x50880088,
	0x28440044,
	0x14220022,
	0xa110011,
	0x5080008,
	0x2040004,

	// a8-h8
	0x402000,
	0xa01000,
	0x508800,
	0x284400,
	0x142200,
	0xa1100,
	0x50800,
	0x20400,
}

var KingMoves [64]uint64 = [64]uint64{
	// a1-h1
	0x40c0000000000000,
	0xa0e0000000000000,
	0x5070000000000000,
	0x2838000000000000,
	0x141c000000000000,
	0xa0e000000000000,
	0x507000000000000,
	0x203000000000000,

	// a2-h2
	0xc040c00000000000,
	0xe0a0e00000000000,
	0x7050700000000000,
	0x3828380000000000,
	0x1c141c0000000000,
	0xe0a0e0000000000,
	0xe0a0e0000000000,
	0x302030000000000,

	// a3-h3
	0xc040c000000000,
	0xe0a0e000000000,
	0x70507000000000,
	0x38283800000000,
	0x1c141c00000000,
	0xe0a0e00000000,
	0x7050700000000,
	0x3020300000000,

	// a4-h4
	0xc040c0000000,
	0xe0a0e0000000,
	0x705070000000,
	0x382838000000,
	0x1c141c000000,
	0xe0a0e000000,
	0x70507000000,
	0x30203000000,

	// a5-h5
	0xc040c00000,
	0xe0a0e00000,
	0x7050700000,
	0x3828380000,
	0x1c141c0000,
	0xe0a0e0000,
	0x705070000,
	0x302030000,

	// a6-g6
	0xc040c000,
	0xe0a0e000,
	0x70507000,
	0x38283800,
	0x1c141c00,
	0xe0a0e00,
	0x7050700,
	0x3020300,

	// a7-h7
	0xc040c0,
	0xe0a0e0,
	0x705070,
	0x382838,
	0x1c141c,
	0xe0a0e,
	0x70507,
	0x30203,

	// a8-h8
	0xc040,
	0xe0a0,
	0x7050,
	0x3828,
	0x1c14,
	0xe0a,
	0x705,
	0x302,
}

var Rays [8][64]uint64 = [8][64]uint64{
	// North
	{},

	// South
	{},

	// East
	{},

	// West
	{},

	// NorthEast
	{},

	// NorthWest
	{},

	// SoutheEast
	{},

	// SouthWest
	{},
}










package backend

import (
	"math/rand"
)

// To speed up Perft and alpha-beta searching my  engine
// uses a transposition table, with Zobrist hashing.

// Each constant here allows us to index the Zobrist Hash based
// on it's color and position. The way the constants are used
// is that each number represents what "chunk" - what group of
// sucessive 64 indexes - in the hash belong to a certian piece
// of a certian color. So for instance, if we assign black knights
// to have the 6th chunk, to get the Zobrist random number for a a
// black knight on a6, we would multiply 64 * 6, to put us at the
// starting index of the black knights chunk, and then add from the
// starting position the position of the square, which in the example,
// would be 40.

const (
	WhitePawnChunkStart = iota
	WhiteKnightChunkStart
	WhiteBishopChunkStart
	WhiteRookChunkStart
	WhiteKingChunkStart
	WhiteQueenChunkStart

	BlackPawnChunkStart
	BlackKnightChunkStart
	BlackBishopChunkStart
	BlackRookChunkStart
	BlackKingChunkStart
	BlackQueenChunkStart
)

// We 12 * 64 random number, 64 squares for
// each of the 12 white and black pieces,
// and a different number for each piece of
// each color on each square.

const (
	ZobristRandomNumbersSize = 12 * 64
	TranspositionTableSize   = 2 ^ 20 + 7
	NoEntry                  = -1
)

type TransTableEntry struct {
	Hash      uint64
	Depth     int
	NodeCount uint64
}

var TranspositionTable [TranspositionTableSize]TransTableEntry
var ZobristRandomNumbers [ZobristRandomNumbersSize]uint64

func init() {
	for index := 0; index < ZobristRandomNumbersSize; index++ {
		ZobristRandomNumbers[index] = rand.Uint64()
	}
	TranspositionTable = [TranspositionTableSize]TransTableEntry{}
}

func computeZobristHash(board *Board) uint64 {
	var hash uint64
	for index := 0; index < 64; index++ {
		if board.Pieces[index] != NoPiece {
			if board.Pieces[index] == Pawn && board.Colors[index] == White {
				hash ^= ZobristRandomNumbers[WhitePawnChunkStart*64+index]
			} else if board.Pieces[index] == Knight && board.Colors[index] == White {
				hash ^= ZobristRandomNumbers[WhiteKnightChunkStart*64+index]
			} else if board.Pieces[index] == Bishop && board.Colors[index] == White {
				hash ^= ZobristRandomNumbers[WhiteBishopChunkStart*64+index]
			} else if board.Pieces[index] == Rook && board.Colors[index] == White {
				hash ^= ZobristRandomNumbers[WhiteRookChunkStart*64+index]
			} else if board.Pieces[index] == Queen && board.Colors[index] == White {
				hash ^= ZobristRandomNumbers[WhiteQueenChunkStart*64+index]
			} else if board.Pieces[index] == King && board.Colors[index] == White {
				hash ^= ZobristRandomNumbers[WhiteKingChunkStart*64+index]
			} else if board.Pieces[index] == Pawn && board.Colors[index] == Black {
				hash ^= ZobristRandomNumbers[BlackPawnChunkStart*64+index]
			} else if board.Pieces[index] == Knight && board.Colors[index] == Black {
				hash ^= ZobristRandomNumbers[BlackKnightChunkStart*64+index]
			} else if board.Pieces[index] == Bishop && board.Colors[index] == Black {
				hash ^= ZobristRandomNumbers[BlackBishopChunkStart*64+index]
			} else if board.Pieces[index] == Rook && board.Colors[index] == Black {
				hash ^= ZobristRandomNumbers[BlackRookChunkStart*64+index]
			} else if board.Pieces[index] == Queen && board.Colors[index] == Black {
				hash ^= ZobristRandomNumbers[BlackQueenChunkStart*64+index]
			} else if board.Pieces[index] == King && board.Colors[index] == Black {
				hash ^= ZobristRandomNumbers[BlackKingChunkStart*64+index]
			}
		}
	}
	return hash
}

func getHashEntry(board *Board, depth int) TransTableEntry {
	hash := computeZobristHash(board)
	entry := TranspositionTable[hash%TranspositionTableSize]
	if entry.Hash == hash && entry.Depth >= depth {
		return entry
	}
	return TransTableEntry{Depth: NoEntry}
}

func setHashEntry(board *Board, depth int, nodeCount uint64) {
	hash := computeZobristHash(board)
	entry := TransTableEntry{Hash: hash, Depth: depth, NodeCount: nodeCount}
	TranspositionTable[hash%TranspositionTableSize] = entry
}






HUUUUGE BUG!!!!!: When you destory the castle kingside rights in board.MakeMove, you ALSO
need to destory the castling queen side rights, and visa versa! Bc if the player has already 
castled to one side, then they can't later castle to the other side!!!!!




package backend

import (
	"fmt"
)

/*
mailbox64 and mailbox120 serve as a mapping between the 8x8 chess board and
the engines internal 10x12 chess board, so that valid moves (i.e moves that
stay on the board and don't wrap around) can be easily tested. The way to
check if a move is valid is by first converting the 8x8 position to the
corresponding 10x12 board position using mailbox64. Then to get the correct
8x8 index for the move, or to test if the move is invalid, the index given by
mailbox64 is offset using the correct move offset, and then used to index
mailbox120. If the move is valid, mailbox120 will have the correct 8x8 position
at the aformentioned index. If it is not, then -1 will be returned and we know
the move is invalid and can discard it.
*/

type MoveType int

const (
	Quiet MoveType = iota
	Attack
	AttackEP

	CastleWKS
	CastleWQS
	CastleBKS
	CastleBQS

	KnightPromotion
	BishopPromotion
	RookPromotion
	QueenPromotion
)

func (moveType MoveType) String() string {
	if moveType == Quiet {
		return "Quiet"
	} else if moveType == Attack {
		return "Attack"
	} else if moveType == AttackEP {
		return "AttackEP"
	} else if moveType == CastleWKS {
		return "CastleWKS"
	} else if moveType == CastleWQS {
		return "CastleWQS"
	} else if moveType == CastleBKS {
		return "CastleBKS"
	} else if moveType == CastleBQS {
		return "CastleBQS"
	} else if moveType == KnightPromotion {
		return "KnightPromotion"
	} else if moveType == BishopPromotion {
		return "BishopPromotion"
	} else if moveType == RookPromotion {
		return "RookPromotion"
	} else if moveType == QueenPromotion {
		return "QueenPromotion"
	} else {
		return "Unknown move type"
	}
}

type Move struct {
	From     int
	To       int
	MoveType MoveType
}

func (move Move) String() string {
	fromSquare := PositionToAlgebraicNotation[move.From]
	toSquare := PositionToAlgebraicNotation[move.To]
	//if move.MoveType == Attack {
	//	return fmt.Sprintf("%vx%v", fromSquare, toSquare)
	//}
	//return fmt.Sprintf("%v-%v", fromSquare, toSquare)
	return fmt.Sprintf("%v-%v (%v-%v) (%v)", fromSquare, toSquare, move.From, move.To, move.MoveType)
}

var Mailbox120 [120]int
var Mailbox64 [64]int

func init() {
	Mailbox120 = [120]int{
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, 0, 1, 2, 3, 4, 5, 6, 7, -1,
		-1, 8, 9, 10, 11, 12, 13, 14, 15, -1,
		-1, 16, 17, 18, 19, 20, 21, 22, 23, -1,
		-1, 24, 25, 26, 27, 28, 29, 30, 31, -1,
		-1, 32, 33, 34, 35, 36, 37, 38, 39, -1,
		-1, 40, 41, 42, 43, 44, 45, 46, 47, -1,
		-1, 48, 49, 50, 51, 52, 53, 54, 55, -1,
		-1, 56, 57, 58, 59, 60, 61, 62, 63, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	}

	Mailbox64 = [64]int{
		21, 22, 23, 24, 25, 26, 27, 28,
		31, 32, 33, 34, 35, 36, 37, 38,
		41, 42, 43, 44, 45, 46, 47, 48,
		51, 52, 53, 54, 55, 56, 57, 58,
		61, 62, 63, 64, 65, 66, 67, 68,
		71, 72, 73, 74, 75, 76, 77, 78,
		81, 82, 83, 84, 85, 86, 87, 88,
		91, 92, 93, 94, 95, 96, 97, 98,
	}
}

// Each delta represents the change required of a pieces index
// to move it one unit in any of the eight directions.
const (
	NorthDelta     = 10
	SouthDelta     = -10
	EastDelta      = 1
	WestDelta      = -1
	NorthEastDelta = 11
	NorthWestDelta = 9
	SouthEastDelta = -11
	SouthWestDelta = -9
)

// Each piece has "deltas", offsets that describe how they can move on the board.
var PieceDeltas map[Piece][]int

func init() {
	PieceDeltas = map[Piece][]int{
		Knight: []int{
			NorthDelta + NorthDelta + EastDelta,
			NorthDelta + EastDelta + EastDelta,
			EastDelta + EastDelta + SouthDelta,
			EastDelta + SouthDelta + SouthDelta,
			WestDelta + SouthDelta + SouthDelta,
			WestDelta + WestDelta + SouthDelta,
			NorthDelta + WestDelta + WestDelta,
			NorthDelta + NorthDelta + WestDelta,
		},
		King: []int{
			NorthDelta,
			SouthDelta,
			EastDelta,
			WestDelta,
			NorthEastDelta,
			NorthWestDelta,
			SouthEastDelta,
			SouthWestDelta,
		},
		Queen: []int{
			NorthDelta,
			SouthDelta,
			EastDelta,
			WestDelta,
			NorthEastDelta,
			NorthWestDelta,
			SouthEastDelta,
			SouthWestDelta,
		},
		Bishop: []int{
			NorthEastDelta,
			NorthWestDelta,
			SouthEastDelta,
			SouthWestDelta,
		},
		Rook: []int{
			NorthDelta,
			SouthDelta,
			EastDelta,
			WestDelta,
		},
	}

	WhitePawNde
}

func ComputePseduolegalMoves(board *Board) (moves []Move) {
	colorToMove := Black
	enemyColor := White
	if board.WhiteToMove {
		colorToMove = White
		enemyColor = Black
	}

	for index := 0; index < 64; index++ {
		piece := board.Pieces[index]
		color := board.Colors[index]

		if color == colorToMove {
			deltas := PieceDeltas[piece]
			if deltas == nil && color == White {
				deltas = 
			}


			for _, delta := range PieceDeltas[piece] {
				to := Mailbox120[Mailbox64[index]+delta]
				if piece == Bishop || piece == Rook || piece == Queen {
					for to != -1 && board.Colors[to] == NoColor {
						moves = append(moves, Move{From: index, To: to, MoveType: Quiet})
						to = Mailbox120[Mailbox64[to]+delta]
					}
					if to != -1 && board.Colors[to] == enemyColor {
						moves = append(moves, Move{From: index, To: to, MoveType: Attack})
					}
				} else {
					if to != -1 && board.Colors[to] != color {
						moveType := Quiet
						if board.Colors[to] == enemyColor {
							moveType = Attack
						}
						moves = append(moves, Move{From: index, To: to, MoveType: moveType})
					}

				}
			}
		}

	}
	return moves
}

func ComputePseduolegalMoves1(board *Board) (moves []Move) {
	colorToMove := Black
	enemyColor := White
	ownAttackSquares := &board.BlackAttackSquares
	if board.WhiteToMove {
		colorToMove = White
		enemyColor = Black
		ownAttackSquares = &board.WhiteAttackSquares
	}

	for index := 0; index < 64; index++ {
		piece := board.Pieces[index]
		color := board.Colors[index]

		if color == colorToMove {
			switch piece {
			case Knight:
				moves = append(moves, computeMovesForNonslider(board, index, color, enemyColor, KnightDeltas[:], ownAttackSquares)...)
			case King:
				moves = append(moves, computeMovesForNonslider(board, index, color, enemyColor, KingDeltas[:], ownAttackSquares)...)
			case Bishop:
				moves = append(moves, computeMovesForSlider(board, index, enemyColor, BishopDeltas[:], ownAttackSquares)...)
			case Rook:
				moves = append(moves, computeMovesForSlider(board, index, enemyColor, RookDeltas[:], ownAttackSquares)...)
			case Queen:
				moves = append(moves, computeMovesForSlider(board, index, enemyColor, QueenDeltas[:], ownAttackSquares)...)
			case Pawn:
				if colorToMove == White {
					moves = append(moves, computeMovesForPawns(board, index, enemyColor, NorthDelta, NorthWestDelta, NorthEastDelta, ownAttackSquares)...)
				} else {
					moves = append(moves, computeMovesForPawns(board, index, enemyColor, SouthDelta, SouthWestDelta, SouthEastDelta, ownAttackSquares)...)
				}
			}
		}

	}
	moves = append(moves, computeCastlingMoves(board)...)
	return moves
}

func computeMovesForNonslider(board *Board, from int, ownColor, enemyColor Color, deltas []int, ownAttackSquares *[64]bool) (moves []Move) {
	for _, delta := range deltas {
		to := Mailbox120[Mailbox64[from]+delta]
		if to != -1 && board.Colors[to] != ownColor {
			moveType := Quiet
			if board.Colors[to] == enemyColor {
				moveType = Attack
			}
			ownAttackSquares[to] = true
			moves = append(moves, Move{From: from, To: to, MoveType: moveType})
		}
	}
	return moves
}

func computeMovesForSlider(board *Board, from int, enemyColor Color, deltas []int, ownAttackSquares *[64]bool) (moves []Move) {
	for _, delta := range deltas {
		to := Mailbox120[Mailbox64[from]+delta]
		for to != -1 && board.Colors[to] == NoColor {
			ownAttackSquares[to] = true
			moves = append(moves, Move{From: from, To: to, MoveType: Quiet})
			to = Mailbox120[Mailbox64[to]+delta]
		}
		if to != -1 && board.Colors[to] == enemyColor {
			ownAttackSquares[to] = true
			moves = append(moves, Move{From: from, To: to, MoveType: Attack})
		}
	}
	return moves
}

func computeMovesForPawns(board *Board, from int, color, enemyColor Color, pushDelta, attackLeftDelta, attackRightDelta int, ownAttackSquares *[64]bool) (moves []Move) {
	// Compute promotion moves first, since if we're promoting a pawn, none of the other
	// pawn moves are valid.
	to := Mailbox120[Mailbox64[from]+pushDelta]
	attackRight := Mailbox120[Mailbox64[from]+attackRightDelta]
	attackLeft := Mailbox120[Mailbox64[from]+attackLeftDelta]

	if (board.WhiteToMove && from >= 48 && from <= 55) || (!board.WhiteToMove && from >= 8 && from <= 15) {
		if !board.WhiteToMove && from >= 8 && from <= 15 {
			to = Mailbox120[Mailbox64[from]+SouthDelta]
		}

		if board.Pieces[to] == NoPiece {
			moves = append(moves, Move{From: from, To: to, MoveType: KnightPromotion})
			computeMovesForNonslider(board, from, color, enemyColor, KnightDeltas[:], ownAttackSquares)
			moves = append(moves, Move{From: from, To: to, MoveType: BishopPromotion})
			moves = append(moves, Move{From: from, To: to, MoveType: RookPromotion})
			moves = append(moves, Move{From: from, To: to, MoveType: QueenPromotion})
		}

		if attackLeft != -1 && board.Colors[attackLeft] == enemyColor {
			moves = append(moves, Move{From: from, To: attackLeft, MoveType: KnightPromotion})
			moves = append(moves, Move{From: from, To: attackLeft, MoveType: BishopPromotion})
			moves = append(moves, Move{From: from, To: attackLeft, MoveType: RookPromotion})
			moves = append(moves, Move{From: from, To: attackLeft, MoveType: QueenPromotion})
		}

		if attackRight != -1 && board.Colors[attackRight] == enemyColor {
			moves = append(moves, Move{From: from, To: attackRight, MoveType: KnightPromotion})
			moves = append(moves, Move{From: from, To: attackRight, MoveType: BishopPromotion})
			moves = append(moves, Move{From: from, To: attackRight, MoveType: RookPromotion})
			moves = append(moves, Move{From: from, To: attackRight, MoveType: QueenPromotion})
		}
	} else {
		// Compute single pawn push moves
		if to != -1 && board.Pieces[to] == NoPiece {
			moves = append(moves, Move{From: from, To: to, MoveType: Quiet})
		}

		// Compute pawn attacks, both normal and en passant
		if attackLeft != -1 && board.Colors[attackLeft] == enemyColor {
			ownAttackSquares[attackLeft] = true
			moves = append(moves, Move{From: from, To: attackLeft, MoveType: Attack})
		} else if attackLeft != -1 && attackLeft == board.EPSquare {
			moves = append(moves, Move{From: from, To: attackLeft, MoveType: AttackEP})
		}

		if attackRight != -1 && board.Colors[attackRight] == enemyColor {
			ownAttackSquares[attackRight] = true
			moves = append(moves, Move{From: from, To: attackRight, MoveType: Attack})
		} else if attackRight != -1 && attackRight == board.EPSquare {
			moves = append(moves, Move{From: from, To: attackRight, MoveType: AttackEP})
		}

		// Compute double pawn push move
		if board.WhiteToMove && from >= 8 && from <= 15 {
			to := Mailbox120[Mailbox64[from]+NorthDelta+NorthDelta]
			inbetween := Mailbox120[Mailbox64[from]+NorthDelta]
			if board.Pieces[to] == NoPiece && board.Pieces[inbetween] == NoPiece {
				moves = append(moves, Move{From: from, To: to, MoveType: Quiet})
			}
		} else if !board.WhiteToMove && from >= 48 && from <= 55 {
			to := Mailbox120[Mailbox64[from]+SouthDelta+SouthDelta]
			inbetween := Mailbox120[Mailbox64[from]+SouthDelta]
			if board.Pieces[to] == NoPiece && board.Pieces[inbetween] == NoPiece {
				moves = append(moves, Move{From: from, To: to, MoveType: Quiet})
			}
		}
	}
	return moves
}

func computeCastlingMoves(board *Board) (moves []Move) {
	if board.WhiteToMove && board.CanCastleWKS && board.Pieces[5] == NoPiece && board.Pieces[6] == NoPiece {
		moves = append(moves, Move{From: 4, To: 6, MoveType: CastleWKS})
	} else if board.WhiteToMove && board.CanCastleWQS && board.Pieces[1] == NoPiece &&
		board.Pieces[2] == NoPiece && board.Pieces[3] == NoPiece {
		moves = append(moves, Move{From: 4, To: 2, MoveType: CastleWQS})
	}
	if !board.WhiteToMove && board.CanCastleBKS && board.Pieces[61] == NoPiece && board.Pieces[62] == NoPiece {
		moves = append(moves, Move{From: 60, To: 62, MoveType: CastleBKS})
	} else if !board.WhiteToMove && board.CanCastleBQS && board.Pieces[59] == NoPiece &&
		board.Pieces[58] == NoPiece && board.Pieces[57] == NoPiece {
		moves = append(moves, Move{From: 60, To: 58, MoveType: CastleBQS})
	}
	return moves
}

/* Since our engine is a pseduo-legal move generator, whenever an invalid
move was made on the last turn, the current turn returns early and indicates
to the last turn via Go's error system that the move it attempted to explore
is invalid. So the move is discarded and the next one is tried.
*/

func Perft(board *Board, depth, divideAt int) uint64 {
	pseduoMoves := ComputePseduolegalMoves1(board)
	var nodes uint64
	if depth == 0 {
		return 1
	}
	for _, move := range pseduoMoves {
		board.DoMove(&move)
		if board.IsInvalid() {
			board.UndoMove(&move)
			continue
		}
		moveNodes := Perft(board, depth-1, divideAt)
		if depth == divideAt {
			fmt.Printf("%v: %v\n", move, moveNodes)
		}
		board.UndoMove(&move)
	}
	return nodes
}












Cases not convered yet:

* Promotion


var Path []Move

func QPerft(board Board, depth int, divideAt int) (error, uint64) {
	moves := ComputeAllLegalMoves(board)
	var nodes uint64
	var err error
	movesToNodes := make(map[Move]uint64)

	if depth == 0 {
		return nil, 1
	}

	for _, move := range moves {
		MakeMove(&board, move)
		if board.ConvertBoardToFENString() == "5Q2/1pk1p2p/1q2r3/2p3P1/2P5/5N2/1P1P4/1NB1P2R w - e3 1 0" {
			fmt.Println("adding move,", move.MoveToString(board), ", at depth:", depth, "turn", !board.WhiteToMove)
			fmt.Println(board.ConvertBoardToFENString())
			fmt.Println()
			Path = append(Path, move)
			return errors.New("error!!!"), 0
		}
		if move.MoveType == AttackEP && kingIsInCheck(board, !board.WhiteToMove) {
			// The case of en-passant putting the king in check
			// is very rare, rare enough to where using the approach
			// of simply undoing such moves if they leave the king in
			// check is faster and easier than trying to check for such
			// a case in the move generation function. Thus, technically,
			// the move generation is still pseduo-legal.
			UndoMove(&board, move)
			continue
		}
		Path = append(Path, move)
		err, movesToNodes[move] = QPerft(board, depth-1, divideAt)
		if err == nil {
			Path = Path[:len(Path)-1]
		} else {
			fmt.Println("adding move,", move.MoveToString(board), ", at depth:", depth, "turn", !board.WhiteToMove)
			fmt.Println(board.ConvertBoardToFENString())
			fmt.Println()
			return err, 0
		}
		nodes += movesToNodes[move]
		UndoMove(&board, move)
	}

	if depth == divideAt {
		for move, nodes := range movesToNodes {
			fmt.Printf("%v: %v\n", move.MoveToString(board), nodes)
		}
	}
	return nil, nodes
}


err, results := backend.QPerft(board, 5, 5)
	if err != nil {
		fmt.Println("error somewhere")
	}
	fmt.Println(backend.Path)
	for _, move := range backend.Path {
		fmt.Println(move.MoveToString(board))
	}
	fmt.Println("Nodes:", results)

func Search1(board Board, alpha, beta, depth int) (Move, int) {
	moves := ComputeAllLegalMoves(board)
	if (depth == 0 && len(moves) != 0) || endOfGame {
		return Move{MoveType: NullMove}, evaluateBoard(board)
	} else if len(moves) == 0 {
		// Checkmate and stalemate
		endOfGame = true
		if kingIsInCheck(board, board.WhiteToMove) && board.WhiteToMove {
			return Move{MoveType: NullMove}, -KingValue
		} else if kingIsInCheck(board, board.WhiteToMove) && !board.WhiteToMove {
			return Move{MoveType: NullMove}, KingValue
		}
		return Move{MoveType: NullMove}, 0

	} else if positionIsDraw(board) {
		endOfGame = true
		return Move{MoveType: NullMove}, 0
	} else if board.WhiteToMove {
		bestMove := Move{MoveType: DefaultMove}
		for _, move := range moves {
			MakeMove(&board, move)
			_, score := Search1(board, alpha, beta, depth-1)
			if score > alpha {
				alpha = score
				bestMove = move
				if alpha >= beta {
					break
				}
			}
			UndoMove(&board, move)
		}
		if bestMove.MoveType == DefaultMove {
			bestMove = moves[0]
		}
		return bestMove, alpha
	} else {
		bestMove := Move{MoveType: DefaultMove}
		for _, move := range moves {
			MakeMove(&board, move)
			_, score := Search1(board, alpha, beta, depth-1)
			if score < beta {
				beta = score
				bestMove = move
				if alpha >= beta {
					break
				}
			}
			UndoMove(&board, move)
		}
		if bestMove.MoveType == DefaultMove {
			bestMove = moves[0]
		}
		return bestMove, beta
	}
}






func moveToStr(move uint16) string {
	from, to, _ := getMoveInfo(move)
	/*moveTypeAsStr := ""
	switch moveType {
	case Quiet:
		moveTypeAsStr = "Quiet"
	case Attack:
		moveTypeAsStr = "Attack"
	case AttackEP:
		moveTypeAsStr = "AttackEP"
	case CastleWKS:
		moveTypeAsStr = "CastleWKS"
	case CastleWQS:
		moveTypeAsStr = "CastleWQS"
	case CastleBKS:
		moveTypeAsStr = "CastleBKS"
	case CastleBQS:
		moveTypeAsStr = "CastleBQS"
	case KnightPromotion:
		moveTypeAsStr = "KnightPromotion"
	case BishopPromotion:
		moveTypeAsStr = "BishopPromotion"
	case RookPromotion:
		moveTypeAsStr = "RookPromotion"
	case QueenPromotion:
		moveTypeAsStr = "QueenPromotion"
	}*/
	//return fmt.Sprintf("%v-%v (%v)", posToCoordinate(int(from)), posToCoordinate(int(to)), moveTypeAsStr)
	return fmt.Sprintf("%v-%v", posToCoordinate(int(from)), posToCoordinate(int(to)))
}

// Check if the player to move is in check
func (board *Board) SideToMoveInCheck() bool {
	if board.WhiteToMove && board.whiteInCheck {
		return true
	} else if !board.WhiteToMove && board.blackInCheck {
		return true
	}
	return false
}

// Determine if an endgame has been reached. Right now
// this is a simple piece count. If there are less than
// a certian amount of pieces, then the endgame has been
// reached.
func (board *Board) endgameReached() bool {
	return bits.OnesCount64(board.PieceBB[WhiteBB]|board.PieceBB[BlackBB]) <= EnginePieceAmtThreshold
}

DoMove!!!!
// Set the check flags to false, since, if the color
// to move is in check, they're about to move out of it,
// and so later on, the check shouldn't stay recorded
board.whiteInCheck = false
board.blackInCheck = false

GenLegalMoves!!!!
if usColor == WhiteBB {
	board.whiteInCheck = true
} else {
	board.blackInCheck = true
}



fmt.Printf("0x%x\n", board.Hash)
	m1 := board.DoMoveFromCoords("a2a4", true)
	m2 := board.DoMoveFromCoords("b7b5", true)
	m3 := board.DoMoveFromCoords("h2h4", true)
	m4 := board.DoMoveFromCoords("b5b4", true)
	m5 := board.DoMoveFromCoords("c2c4", true)
	m6 := board.DoMoveFromCoords("b4c3", true)
	m7 := board.DoMoveFromCoords("a1a3", true)
	fmt.Printf("0x%x\n", board.Hash)
	board.UndoMove(&m7)
	board.UndoMove(&m6)
	board.UndoMove(&m5)
	board.UndoMove(&m4)
	board.UndoMove(&m3)
	board.UndoMove(&m2)
	board.UndoMove(&m1)
	fmt.Printf("0x%x\n", board.Hash)

	/*fmt.Println("=========")
	var x uint64 = 0x652a607ca3f242c1
	x ^= core.Random64[core.SideToMove]
	x ^= core.Random64[core.CastleWKSHash]
	x ^= core.Random64[core.CastleWQSHash]
	fmt.Printf("NOW: 0x%x\n", x)
	x ^= core.Random64[core.WhiteKing*64+12]
	x ^= core.Random64[core.WhiteKing*64+4]
	x ^= core.GetEPFileHash(core.CoordinateToPos("f6"))
	fmt.Printf("0x%x\n", x)*/


rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1 ;D1 20 ;D2 400 ;D3 8902 ;D4 197281 ;D5 4865609 ;D6 119060324






